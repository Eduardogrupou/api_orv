"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.next = void 0;
const fetch_cookie_1 = __importDefault(require("fetch-cookie"));
const form_data_1 = __importDefault(require("form-data"));
const http_1 = __importDefault(require("http"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const test_listen_1 = __importDefault(require("test-listen"));
const url_1 = require("url");
function request(url, { method = 'GET', headers = {}, cookies = {}, body = undefined, } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const cookie = Object.entries(cookies)
            .map(([key, value]) => `${key}=${value}`)
            .join(';');
        const fetcher = (0, fetch_cookie_1.default)(node_fetch_1.default);
        const response = yield fetcher(url, {
            method,
            headers: Object.assign({ 
                // default to json, as that works easiest in tests
                'content-type': 'application/json', accept: 'application/json', cookie }, headers),
            body: body instanceof form_data_1.default
                ? body
                : typeof body === 'string'
                    ? body
                    : JSON.stringify(body),
        });
        return {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
            body: yield response.json(),
        };
    });
}
function next(getServerSideProps) {
    return __awaiter(this, void 0, void 0, function* () {
        let lastRequest;
        const server = http_1.default.createServer((req, res) => {
            lastRequest = Date.now();
            getServerSideProps({
                req,
                res,
                // https://github.com/vercel/next.js/blob/07fe406bd5c25e69f3c62dabf200c8488f97d7d2/packages/next/server/next-server.ts#L1645
                query: (0, url_1.parse)(req.url || '', true).query,
            })
                .then((result) => {
                if (!res.writableEnded) {
                    res.write(JSON.stringify(result));
                    res.end();
                }
            })
                // We only do this in the test server, so we can validate the handle function
                // maybe we should do this in real as well? I mean, return errors in the
                // response, instead of just throwing and leaving it up to the user to handle?
                .catch((e) => {
                res.statusCode = 500;
                res.write(JSON.stringify(e));
                res.end();
            });
        });
        const interval = setInterval(() => {
            if (!lastRequest || Date.now() - lastRequest < 250)
                return;
            clearInterval(interval);
            server.close();
        }, 25);
        const url = yield (0, test_listen_1.default)(server);
        const fetch = (path = '/', options) => __awaiter(this, void 0, void 0, function* () { return request(`${url}${path}`, options); });
        fetch.url = url;
        return fetch;
    });
}
exports.next = next;
//# sourceMappingURL=server.js.map