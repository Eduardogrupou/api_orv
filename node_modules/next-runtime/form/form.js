"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Form = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const router_1 = require("next/router");
const react_1 = require("react");
const use_latest_ref_1 = require("../lib/use-latest-ref");
const dom_1 = require("./dom");
const store_1 = require("./store");
function FormComponent(_a, ref) {
    var { method, action, encType, onSubmit, onSuccess, onError } = _a, props = __rest(_a, ["method", "action", "encType", "onSubmit", "onSuccess", "onError"]);
    const submit = (0, store_1.useFormStoreSubmit)();
    const router = (0, router_1.useRouter)();
    const onSuccessRef = (0, use_latest_ref_1.useLatestRef)(onSuccess);
    const onErrorRef = (0, use_latest_ref_1.useLatestRef)(onError);
    const handleSubmit = (0, react_1.useCallback)((event) => __awaiter(this, void 0, void 0, function* () {
        onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(event);
        if (event.defaultPrevented)
            return;
        event.preventDefault();
        // <button>/<input type="submit"> may override attributes of <form>
        const submitter = (0, dom_1.getFormSubmitter)(event);
        const form = submitter ? submitter.form : event.currentTarget;
        if (!form) {
            throw new Error('Cannot submit a <button> without a <form>');
        }
        if (submitter && !(0, dom_1.isValidFormSubmitter)(submitter)) {
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        }
        const formData = new FormData(form);
        const formMethod = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formmethod')) ||
            form.getAttribute('method') ||
            method ||
            'post';
        const formAction = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formaction')) ||
            form.getAttribute('action') ||
            action ||
            location.href.split('?')[0];
        // Include name + value from the submitter
        if (submitter === null || submitter === void 0 ? void 0 : submitter.name) {
            formData.set(submitter.name, submitter.value);
        }
        submit({
            name: props.name,
            router,
            formData,
            formAction,
            method: formMethod,
            // need to wrap the callbacks like this so the latest ref value is accessed
            // at the time the callbacks are invoked, otherwise we could pass in a stale callback
            onError: (state) => {
                var _a;
                (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, state);
            },
            onSuccess: (state) => {
                var _a;
                (_a = onSuccessRef.current) === null || _a === void 0 ? void 0 : _a.call(onSuccessRef, state);
            },
        });
    }), [
        method,
        onErrorRef,
        onSubmit,
        onSuccessRef,
        action,
        props.name,
        router,
        submit,
    ]);
    return ((0, jsx_runtime_1.jsx)("form", Object.assign({}, props, { ref: ref, action: action, encType: encType, method: method, onSubmit: handleSubmit }), void 0));
}
/**
 * Replace your `form` with `Form` to submit it clientside using `fetch`, and get
 * access to the serialized form data in `usePendingSubmit()` to build a great
 * looking loading status.
 */
// the cast ensures we can use the generic on the form component
exports.Form = (0, react_1.forwardRef)(FormComponent);
//# sourceMappingURL=form.js.map