"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bodyparser = void 0;
const attr_accept_1 = __importDefault(require("attr-accept"));
const body_parser_1 = __importDefault(require("body-parser"));
const busboy_1 = __importDefault(require("busboy"));
const bytes_1 = __importDefault(require("bytes"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const picoid_1 = __importDefault(require("picoid"));
const set_field_1 = require("./set-field");
const ACCEPT = [
    'application/json',
    'application/x-www-form-urlencoded',
    'multipart/form-data',
];
function bodyparser(req, res, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const uploadDir = (options === null || options === void 0 ? void 0 : options.uploadDir) || os_1.default.tmpdir();
        const limits = (options === null || options === void 0 ? void 0 : options.limits) || {};
        const errors = [];
        // convert string based sizes to numbers
        const maxFileCount = limits.fileCount || undefined;
        const maxFileSize = bytes_1.default.parse(limits.fileSize || '') || undefined;
        const maxFieldSize = bytes_1.default.parse(limits.fieldSize || '') || undefined;
        const maxJsonSize = bytes_1.default.parse(limits.jsonSize || '') || undefined;
        if (!req.headers['content-type'])
            return null;
        if (!ACCEPT.some((type) => { var _a; return (_a = req.headers['content-type']) === null || _a === void 0 ? void 0 : _a.startsWith(type); })) {
            return null;
        }
        // application/json is handled by bodyParser, as busboy doesn't support it
        if (req.headers['content-type'].startsWith('application/json')) {
            let lastKey;
            const jsonParser = body_parser_1.default.json({
                limit: maxJsonSize,
                reviver: maxFieldSize
                    ? (key, value) => {
                        if (typeof value === 'string' && value.length > maxFieldSize) {
                            const field = /[0-9]+/.test(key) ? `${lastKey}.${key}` : key;
                            errors.push({
                                name: 'FIELD_SIZE_EXCEEDED',
                                message: `field "${field}" exceeds ${(0, bytes_1.default)(maxFieldSize)}`,
                            });
                        }
                        lastKey = /[0-9]+/.test(key) ? lastKey : key;
                        return value;
                    }
                    : undefined,
            });
            return new Promise((resolve, reject) => jsonParser(req, res, (error) => {
                if ((error === null || error === void 0 ? void 0 : error.type) === 'entity.too.large') {
                    errors.push({
                        name: 'JSON_SIZE_EXCEEDED',
                        message: `json object exceeds ${(0, bytes_1.default)(maxJsonSize || 0)}`,
                    });
                }
                if (errors.length) {
                    return reject({ errors });
                }
                resolve(req.body);
            }));
        }
        // busboy handles application/x-www-form-urlencoded and multipart/form-data,
        return new Promise((resolve, reject) => {
            const busboy = new busboy_1.default({
                headers: req.headers,
                limits: {
                    files: maxFileCount,
                    fileSize: maxFileSize,
                    fieldSize: maxFieldSize,
                },
            });
            const data = {};
            // We don't want to have these heavy ops when the developer didn't think of it.
            if (maxFileCount || (options === null || options === void 0 ? void 0 : options.uploadDir) || (options === null || options === void 0 ? void 0 : options.onFile)) {
                busboy.on('file', (field, file, name, encoding, type) => __awaiter(this, void 0, void 0, function* () {
                    const value = { name, type, size: 0 };
                    // skip empty fields
                    if (!value.name)
                        return file.resume();
                    if (limits.mimeType && !(0, attr_accept_1.default)({ name, type }, limits.mimeType)) {
                        errors.push({
                            name: 'FILE_TYPE_REJECTED',
                            message: `file "${value.name}" is not of type "${limits.mimeType}"`,
                        });
                        return file.resume();
                    }
                    if (options === null || options === void 0 ? void 0 : options.onFile) {
                        options.onFile({ field, file: value, stream: file });
                    }
                    else {
                        // write to disk when the user doesn't provide an onFile handler
                        yield fs_1.default.promises.mkdir(uploadDir, { recursive: true });
                        value.path = path_1.default.join(uploadDir, path_1.default.basename(field) + '_' + (0, picoid_1.default)(17));
                        file.pipe(fs_1.default.createWriteStream(value.path));
                    }
                    file.on('data', (data) => {
                        value.size = data.length;
                    });
                    file.on('end', () => __awaiter(this, void 0, void 0, function* () {
                        if (file.truncated) {
                            return errors.push({
                                name: 'FILE_SIZE_EXCEEDED',
                                message: `file "${value.name}" exceeds ${(0, bytes_1.default)(maxFileSize || 0)}`,
                            });
                        }
                        return (0, set_field_1.setField)(data, field, value);
                    }));
                }));
            }
            busboy.on('field', function (field, value, _, truncated) {
                if (truncated) {
                    return errors.push({
                        name: 'FIELD_SIZE_EXCEEDED',
                        message: `field "${field}" exceeds ${(0, bytes_1.default)(maxFieldSize || 0)}`,
                    });
                }
                (0, set_field_1.setField)(data, field, value);
            });
            busboy.on('filesLimit', () => {
                errors.push({
                    name: 'FILE_COUNT_EXCEEDED',
                    message: `file count exceeds ${maxFileCount}`,
                });
            });
            busboy.on('finish', () => {
                if (errors.length > 0) {
                    return reject({ errors });
                }
                req.body = data;
                // push it to a next frame, so that onFile promises complete first
                setTimeout(() => {
                    resolve(data);
                }, 0);
            });
            req.pipe(busboy);
        });
    });
}
exports.bodyparser = bodyparser;
//# sourceMappingURL=body-parser.js.map