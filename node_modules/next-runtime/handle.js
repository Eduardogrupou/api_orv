"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handle = void 0;
const accepts_1 = __importDefault(require("accepts"));
const http_methods_1 = require("./http-methods");
const log_1 = require("./lib/log");
const middleware_1 = require("./lib/middleware");
const response_utils_1 = require("./lib/response-utils");
const responses_1 = require("./responses");
const body_parser_1 = require("./runtime/body-parser");
const cookies_1 = require("./runtime/cookies");
const headers_1 = require("./runtime/headers");
const query_params_1 = require("./runtime/query-params");
/**
 * Transfer the properties from the Response object to the response to
 * the response stream, and return a next compatible object.
 */
function applyResponse(response, target, accept) {
    if (!(0, response_utils_1.isTypedResponse)(response)) {
        return response;
    }
    if (response.status) {
        target.statusCode = response.status;
    }
    if (response.statusText) {
        target.statusMessage = response.statusText;
    }
    if (response.headers) {
        for (const key of Object.keys(response.headers)) {
            target.setHeader(key, response.headers[key]);
        }
        switch (accept) {
            case 'html': {
                target.setHeader('Content-Type', 'text/html; charset=utf-8');
                break;
            }
            case 'json': {
                target.setHeader('Content-Type', 'application/json; charset=utf-8');
                break;
            }
        }
    }
    if ('notFound' in response.body) {
        return { notFound: response.body.notFound };
    }
    if ('redirect' in response.body) {
        return { redirect: response.body.redirect };
    }
    return { props: response.body.props || {} };
}
/**
 * sometimes we don't want to return real data, as next might use that to add
 * not-found or redirect headers. Which then cause `sorry, headers already sent`
 * errors
 */
const VOID_NEXT_RESPONSE = { props: { dummy: '' } };
function assertRequestBody(context) {
    // intentionally left blank, we don't care much about it
}
function assertRequestMethod(context) {
    var _a;
    context.req.method = ((_a = context.req.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || 'GET';
}
function handle(handlers) {
    // wrap handlers with middlewares here, so we only do that during build time
    handlers.get = (0, middleware_1.applyMiddlewares)(handlers.use, handlers.get);
    handlers.post = (0, middleware_1.applyMiddlewares)(handlers.use, handlers.post);
    handlers.put = (0, middleware_1.applyMiddlewares)(handlers.use, handlers.put);
    handlers.delete = (0, middleware_1.applyMiddlewares)(handlers.use, handlers.delete);
    handlers.patch = (0, middleware_1.applyMiddlewares)(handlers.use, handlers.patch);
    return (context) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const accept = (0, accepts_1.default)(context.req).type(['html', 'json']);
        const method = (((_a = context.req.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || 'get');
        // also handle complex objects in query params
        context.query = (0, query_params_1.expandQueryParams)(context.query);
        // extend the context
        (0, cookies_1.bindCookieJar)(context);
        (0, headers_1.bindTypedHeaders)(context);
        assertRequestBody(context);
        assertRequestMethod(context);
        if (http_methods_1.httpMethodsWithBody.includes(method)) {
            yield (0, body_parser_1.bodyparser)(context.req, context.res, {
                limits: handlers.limits,
                onFile: handlers.upload,
                uploadDir: handlers.uploadDir,
            });
        }
        let response;
        const handler = handlers[method];
        if (typeof handler === 'function') {
            try {
                response = (yield handler(context));
            }
            catch (e) {
                // If an Response is thrown, (throw json(...)), we'll handle those as response
                // objects. This allows the user to break out api handlers in nested functions
                if ((0, response_utils_1.getResponseType)(e) !== 'unknown') {
                    response = e;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            response = (0, responses_1.notFound)();
        }
        const propResult = applyResponse(response, context.res, accept);
        if ('redirect' in propResult) {
            return propResult;
        }
        // Note, we can't make this api first. That will break shallow rerender
        switch (accept) {
            case 'html': {
                return propResult;
            }
            case 'json': {
                // keep write and end separated for Next12 compatibility.
                context.res.write(JSON.stringify('props' in propResult ? propResult.props : {}));
                context.res.end();
                return VOID_NEXT_RESPONSE;
            }
            default: {
                log_1.log.info('unsupported mime type requested');
                return VOID_NEXT_RESPONSE;
            }
        }
    });
}
exports.handle = handle;
//# sourceMappingURL=handle.js.map